### 一、插入排序的思想：
##### 1.什么是插入排序：
- 对一串数据进行排序的时候，分为已排序部分和未排序部分两部分，将未排序部分的第一个元素直接插入到已排序部分的确定位置中，从而形成一个新的已排序部分，直到为排序部分中没有元素，这种排序方式就叫做插入排序。
##### 2.插入排序的思维过程：
- 由于插入排序的使用前提是要有已排序部分，对于一个数组来讲，我们可以把数组中的第一个元素当成一个有序数列。
[![vB03Yq.png](https://s1.ax1x.com/2022/08/17/vB03Yq.png)](https://imgtu.com/i/vB03Yq)
- 现在，未排序部分的第一个元素的下标就是“1”，我们从下标为1的地方开始进行插入排序。
- 首先，array[1] = 25放到一个暂存区里面，之后array[1]这个位置就属于有序数列存储的一部分，我们通过插入算法将25插入到之前的有序数列中，得到一个新的数组如下：
[![vBBkB4.png](https://s1.ax1x.com/2022/08/17/vBBkB4.png)](https://imgtu.com/i/vBBkB4)
- 现在，未排序部分的第一个元素下标是“2” ， 我们从下标为2的地方开始进行插入排序。
- 首先，array[2] = 22放到一个暂存区里面，之后array[2]这个位置就属于有序数列存储的一部分，我们通过插入算法将22插入到之前的有序数列中，得到一个新的数组如下：
[![vBB280.png](https://s1.ax1x.com/2022/08/17/vBB280.png)](https://imgtu.com/i/vBB280)
- 现在，未排序部分的第一个元素下标是“3” ， 我们从下标为3的地方开始进行插入排序。
- 首先，array[3] = 10放到一个暂存区里面，之后array[3]这个位置就属于有序数列存储的一部分，我们通过插入算法将10插入到之前的有序数列中，得到一个新的数组如下：
[![vBBTa9.png](https://s1.ax1x.com/2022/08/17/vBBTa9.png)](https://imgtu.com/i/vBBTa9)
- 现在，未排序部分的第一个元素下标是“4” ， 我们从下标为4的地方开始进行插入排序。
- 首先，array[4] = 19放到一个暂存区里面，之后array[4]这个位置就属于有序数列存储的一部分，我们通过插入算法将19插入到之前的有序数列中，得到一个新的数组如下：
[![vBBjKO.png](https://s1.ax1x.com/2022/08/17/vBBjKO.png)](https://imgtu.com/i/vBBjKO)
- 现在，未排序部分的第一个元素下标是“5” ， 我们从下标为5的地方开始进行插入排序。
- 首先，array[5] = 23放到一个暂存区里面，之后array[5]这个位置就属于有序数列存储的一部分，我们通过插入算法将25插入到之前的有序数列中，得到一个新的数组如下：[![vBDUo9.png](https://s1.ax1x.com/2022/08/17/vBDUo9.png)](https://imgtu.com/i/vBDUo9)
- 现在，未排序部分的第一个元素下标是“5” ， 我们从下标为5的地方开始进行插入排序。
- 首先，array[5] = 23放到一个暂存区里面，之后array[5]这个位置就属于有序数列存储的一部分，我们通过插入算法将25插入到之前的有序数列中，得到一个新的数组如下：
[![vBDcee.png](https://s1.ax1x.com/2022/08/17/vBDcee.png)](https://imgtu.com/i/vBDcee)___排序完成，我们可以发现七个元素最终使用六次插入算法完成排序。___
##### 3.插入算法：
- 在插入排序的整体过程中，我们可以发现插入算法是完成插入排序最重要的部分，插入算法的复杂度决定了整个插入排序的复杂度。
- 把一个元素按照顺序插入到一个有序数列中有两种主流方式：顺序插入和二分插入。
___顺序插入：___
[![vBBjKO.png](https://s1.ax1x.com/2022/08/17/vBBjKO.png)](https://imgtu.com/i/vBBjKO)1.首先，把19和25进行比较，19 < 25，说明19应该在25的左侧，因此把25移动到array[4]的位置上。
2.其次，把19和22进行比较，19 < 22，说明19应该在22的左侧，因此把22移动到array[3]的位置上。
3.其次，把19和21进行比较，19 < 21，说明19应该在21的左侧，因此把21移动到array[2]的位置上。
4.最后，把19和10进行比较，19 > 10，说明19在10的右侧，现在可以唯一确定19的位置，所以直接把19放在array[1]的位置上。
___@我们发现，顺序插入需要按顺序逐一进行比较，直到找到对应位置，这样比较花费时间，因此接下来的二分插入是更加常用的插入方式。__
___二分插入：___
- 我们来分析一下，二分查找是在一个数组中使用二分的思想查找某个元素是否存在；而二分插入是利用二分的思想，在数组中寻找到合适的插入点，寻找到合适的插入点之后，将右侧的有序数列整体移动一位即可，这就是二分插入的基本思想。
- 因此，查找某个元素与查找插入点的算法相同。
[![vBBjKO.png](https://s1.ax1x.com/2022/08/17/vBBjKO.png)](https://imgtu.com/i/vBBjKO)1.首先，我们需明确已排序部分下标：0、1、2、3，我们设置一个start变量指向下标0，设置一个end变量指向下标3，设置一个mid变量指向下标（0 + 3）/ 2 = 1；
2.把19和中间值array[mid] = 21进行比较之后发现，19 < 21，因此继续查找位置。
3.此时end = mid - 1 = 0，因此mid = 0，把19和中间值10进行比较，19 > 10 ，此时找到了插入点，即mid+1的位置，因此从mid+1开始，把array[1]、[2]、[3]上面的元素全部后移一位，然后把19插入到array[1]的位置。
[![vBDUo9.png](https://s1.ax1x.com/2022/08/17/vBDUo9.png)](https://imgtu.com/i/vBDUo9)1.首先，我们需明确已排序部分下标：0、1、2、3、4，我们设置一个start变量指向下标0，设置一个end变量指向下标4，设置一个mid变量指向下标（0 + 4）/ 2 = 2；
2.把23和中间值array[mid] = 21进行比较之后发现，23 > 21，此时说明23应该插入在21的右区间，继续二分。
3.start = mid + 1 = 3，此时mid =（3 + 4）/ 2  = 3，把23和中间值22进行比较，23 > 22 ，此时说明23应该插入到22的右区间，继续二分。
4.start = mid + 1 = 4，此时mid = 4，start = end，把23和中间值25进行比较，23 < 25，因此从mid开始，把array[4]向后移动一位，然后把23插入array[4]的位置上。
___@分析：___
- 通过上面的两组二分插入，我们可以得出当start = end = mid的时候，就是找到插入点的时候，其他时候都是在寻找插入点。
- 最终插入的位置分两种情况：如果temp < array[mid]，那么插入点是mid；如果temp > array[mid]，那么插入点是mid+ 1。
- 特别注意，使用二分插入的时候，start最终的值就是插入点的位置，这点见代码分析。
### 二、插入排序的代码实现：
##### 1.顺序插入排序：
```C
void InsertSort(int* array , int length)
{
	for (int i = 1 ; i < length ; i++)
	{
		int temp = array[i];
		OrderInsert(array , i , temp);	
	}
	return;
}
void OrderInsert(int* array , int index , int temp)
//这里的index是temp元素的下标，并且这个index也是已排序序列的长度。
{
	while (temp < array[index - 1] && index >= 1)
	//顺序寻找插入点，从已排序序列的最后一个元素进行比较，如果比这个元素要小，就先把这个元素向后移动一位，在和倒数第二个进行比较......
	//由于index从1开始，因此index - 1最小为。
	{
		array[index] = array[index - 1];
		index--;
	}
	//当temp比某个元素大或者已经把所有元素都比较完毕，说明找到了插入点，此时的插入点就是index。
	array[index] = temp;
	return;
}
```
##### 2.二分插入排序：
```C
void InsertSort(int* array , int length)
{
	for (int i = 1 ; i < length ; i++)
	{
		int temp = array[i];
		BinaryInsert(array , i , temp);	
	}
	return;
}
void BinaryInsert(int* array , int index , int temp)
{
	int length = index;//length表示的是已排序部分的长度。
	int start = 0;
	int end = length - 1;
	
	while (start <= end)
	{
		int mid = (start + end) / 2;
		if (temp > array[mid])
			start = mid + 1;
		else
			end = mid - 1;
	}
	//上述过程为二分查找插入点的过程,在最后一次比较的时候，也就是start = end = mid之后一次的比较：
	//如果temp > array[mid]，那么插入点是mid + 1,正好等于循环之后start的值；
	//如果temp < array[mid]，那么插入点是mid,由于mid = start，并且二者最后都没进行改变，因此正好等于循环之后start的值。
	for (int i = length - 1 ; i >= start ; i--)
		array[i + 1] = array[i];
	//这里要注意，把插入点和插入点之后的元素进行移动的时候要从后向前移动，这样确保移动的时候元素不会被覆盖。
	array[start] = temp;
	//最后将temp写入插入点。
	return;
}
```
